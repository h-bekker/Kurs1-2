1. void C::g() {
		C::x=A::f();
		C::f(3);
		C::x=::f(4,5);
		C::x=6;
		}
	
	int main(void) {
		C c;
		c.A::f();
		c.C::f(7);
		::x=::f('8',9);
		return -1;
		}

4. const complex operator*(const complex <T> &a) {
   		complex tmp(re*a.re-im*a.im, im*a.re+re*a.im);
		return tmp;
    	}

const должен присутствовать для того, чтобы не было записи вида c=a*b=d;

5. Судя по баллам, ошибкой является отсутствие примеров. Мне показалось, что достаточно привести один пример, но видимо, и тот был неправильный. 
Пример на статический полиморфизм:
	void f(char);
	void f(double);
	...
	void g(...f('a')...);
вызовется f(char) по best-matching

Пример на динамический полиморфизм:
	class A {
		public:
			virtual void f(int i);
			...
		}
	class B: public A {
		public:
			virtual void f(int j);
			...
		}
	
Пример на параметрический полиморфизм:
	template <class T> T min(T &x, T &y) {
		return x>y ? y : x;
		}
	
	int a,b,p;
	double c,d,q;
	p=min <int> (a,b);
	q=min <double> (c,d);
	
6. Ошибка моя состояла в том, что я не учёл (не вспомнил) про свёртку стека при окончании try-блока. Таким образом, по окончанию try-блока должен вызываться деструктор и только после печатается cout перед return, а не наоборот, как я предполагал. Таким образом, ответ 10 1 10 6 8 5 14 

7. Сперва выбираются функции по количеству параметров и по типам, точно подходящим либо приводящимися по каким-либо преобразованиям. Далее по best-matching выбираются оптимальные функции для каждого параметра. И если пересечение множеств выбранных функции состоит из одной функции, то вызов разрешим. Если же пересечение пустое либо состоит из более чем одной функции - ошибка. А примеры у меня должны быть правильными

8. 
void g (vector <int> & v, list <int> & l, int n) {
	vector <int> :: const_iterator p=v.begin();
	for (int i=0; i<v.size(); i++) {
		if (*p>n)
			l.push_back(v[i]);
		p++;
		}
	}
